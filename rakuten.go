package rakutenapi

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"strconv"
)

type Service struct {
	ApplicationId string //アプリケーションID
	AffiliateId   string //アフェリエイトID
	BasePath      string //リクエストするベースURL
	RakutenSearch *RakutenSearchService
}

// 新しいRakutenSearchServiceを定義する
func NewRakutenSearch(s *Service) *RakutenSearchService {
	rs := &RakutenSearchService{s: s}
	return rs
}

func (r *RakutenSearchService) Get() *RakutenSearch {
	return &RakutenSearch{S: r.s}
}

type RakutenSearchService struct {
	s *Service
}

// 楽天アフェリエイトIDを設定する
func (r *Service) AffId(AffiliateId string) *Service {
	r.AffiliateId = AffiliateId
	return r
}

type RakutenSearch struct {
	//API参考 https://webservice.rakuten.co.jp/documentation/ichiba-product-search
	S        *Service
	Keyword_ string //UTF-8でエンコードした文字列。keyword GenreIDのどちらかは必須
	GenreId_ string //楽天市場におけるジャンルを検索するためのID

	//実装予定なし
	// ProductId string //楽天プロダクト用の製品ID。他のAPIパラメタとの併用は不可
	// OrFlag               int  //複数キーワードが設定された場合に、AND検索、OR検索のいずれかが選択可能。 0:AND検索 1:OR検索

	Hits_ uint64 //取得数。1~30までの整数
	Page_ uint64 //ページ数 1~100までの整数
	// 	0：楽天標準ソート順
	//	1：発売日順（降順）
	//	2：発売日順（昇順）
	//	3：売上順（降順）
	//	4：売上順（昇順）
	//	5：満足順（降順）
	//	6：満足順（昇順）
	// ※UTF-8でURLエンコードされている必要があります。
	Sort_                 uint64
	MinPrice_             uint64 //検索時の最小値段設定。1以上999,999,999以下の整数
	MaxPrice_             uint64 //検索時の最大値段設定。1以上999,999,999以下の整数
	GenreInformationFlag_ bool   //false :ジャンルごとの商品数の情報を取得しない。true :ジャンルごとの商品数の情報を取得する
}

// false :ジャンルごとの商品数の情報を取得しない。true :ジャンルごとの商品数の情報を取得する
func (r *RakutenSearch) GenreInformationFlag(GenreInformationFlag bool) *RakutenSearch {
	r.GenreInformationFlag_ = GenreInformationFlag
	return r
}

// 検索時の最大値段設定。1以上999,999,999以下の整数
func (r *RakutenSearch) MaxPrice(maxPrice uint64) *RakutenSearch {
	r.MaxPrice_ = maxPrice
	return r
}

// 検索時の最小値段設定。1以上999,999,999以下の整数
func (r *RakutenSearch) MinPrice(minPrice uint64) *RakutenSearch {
	r.MinPrice_ = minPrice
	return r
}

// ソートの方法を設定
//
//	0：楽天標準ソート順
//	1：発売日順（降順）
//	2：発売日順（昇順）
//	3：売上順（降順）
//	4：売上順（昇順）
//	5：満足順（降順）
//	6：満足順（昇順）
//
// ※UTF-8でURLエンコードされている必要があります。
func (r *RakutenSearch) Sort(sort uint64) *RakutenSearch {
	r.Sort_ = sort
	return r
}

// 検索するページを設定する
func (r *RakutenSearch) Page(page uint64) *RakutenSearch {
	r.Page_ = page
	return r
}

// 検索の最大数数を設定する
func (r *RakutenSearch) Hits(Hits uint64) *RakutenSearch {
	r.Hits_ = Hits
	return r
}

// 検索のキーワードを設定する
func (r *RakutenSearch) Keyword(SearchWord string) *RakutenSearch {
	r.Keyword_ = url.QueryEscape(SearchWord)
	return r
}

// 楽天APIから取得をする
func (r RakutenSearch) Do() (AutoGenerated, error) {
	var responseBodyFromRakutenAPIData AutoGenerated

	urls := r.S.BasePath + "/services/api/IchibaItem/Search/20220601?format=json"
	urls += "&applicationId=" + r.S.ApplicationId

	if len(r.S.AffiliateId) != 0 {
		urls += "&affiliateId=" + r.S.AffiliateId
	}
	//キーワード設定
	if len(r.Keyword_) == 0 && len(r.GenreId_) == 0 {
		return responseBodyFromRakutenAPIData, fmt.Errorf("keyword or itemCode is essential parameter")
	} else if len(r.GenreId_) != 0 && len(r.Keyword_) != 0 {
		urls += "&keyword=" + url.QueryEscape(r.Keyword_)
		urls += "&genreId=" + url.QueryEscape(r.GenreId_)
	} else if len(r.Keyword_) != 0 {
		urls += "&keyword=" + url.QueryEscape(r.Keyword_)
	} else if len(r.GenreId_) != 0 {
		urls += "&genreId=" + url.QueryEscape(r.GenreId_)
	}

	//検索数
	if r.Hits_ != 0 {
		urls += "&hits=" + strconv.FormatUint(r.Hits_, 10)
	}

	//検索ページ
	if r.Page_ != 0 {
		urls += "&page=" + strconv.FormatUint(r.Page_, 10)
	}
	//ソート
	// 	0：楽天標準ソート順
	//	1：発売日順（降順）
	//	2：発売日順（昇順）
	//	3：売上順（降順）
	//	4：売上順（昇順）
	//	5：満足順（降順）
	//	6：満足順（昇順）
	switch r.Sort_ {
	case 0:
		urls += "&Sort=standard"
	case 1:
		urls += "&Sort=-releaseDate"
	case 2:
		urls += "&Sort=+releaseDate"
	case 3:
		urls += "&Sort=-seller"
	case 4:
		urls += "&Sort=+seller"
	case 5:
		urls += "&Sort=-satisfied"
	case 6:
		urls += "&Sort=+satisfied"
	default:
		return responseBodyFromRakutenAPIData, fmt.Errorf("0-6の正しい値を入力してください")
	}

	//MinPrice
	if r.MinPrice_ != 0 {
		urls += "&minPrice=" + strconv.FormatUint(r.MinPrice_, 10)
	}

	//MaxPrice
	if r.MaxPrice_ != 0 {
		urls += "&maxPrice=" + strconv.FormatUint(r.MaxPrice_, 10)
	}

	//ジャンルごとの商品数取得フラグ
	if r.GenreInformationFlag_ {
		urls += "&genreInformationFlag=1"
	} else {
		urls += "&genreInformationFlag=0"
	}

	body, err := requestServe(urls)

	log.Println(body)

	err = json.Unmarshal(body, &responseBodyFromRakutenAPIData)

	if err != nil {
		log.Panic("Json.Unmarshal :", err)
	}

	return responseBodyFromRakutenAPIData, nil
}

func requestServe(urls string) ([]byte, error) {
	response, err := http.Get(urls)

	if err != nil {
		return nil, fmt.Errorf("API call failed. :%s", err)
	}

	defer response.Body.Close()
	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		log.Panic("ioutil.ReadAll :", err)
	}
	if len(body) == 0 {
		return nil, fmt.Errorf("bad request url:%s data:%s", urls, body)
	}
	return body, nil
}
